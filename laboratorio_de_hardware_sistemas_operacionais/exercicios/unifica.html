<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="utf-8" />
        <title>Exercícios Lab de Hardware e S.Os</title>
        <style>
            body {
                font-family: Arial, Helvetica, sans-serif;
            }

            body > header > ul {
                background-color: black;
                padding: 10px;
                border-radius: 15px;
            }

            body > header > ul > li {
                color: rgb(198, 193, 193);
                list-style: none;
                display: inline;
                margin-left: 15px;
                cursor:pointer;
            }

            body > header > ul > li:hover {
                color: #fff;
            }

            body > main > section {
                margin-bottom: 15px;
            } 
            
            body > main {
                min-height: 800px;
            }

            body > footer {
                color: #fff;
                background-color: black;
                height: 200px;
                text-align: center;
            }

            body > footer > span {
                display: block;
                position: relative;
                top: 40px;
                font-weight: 600;
            }

            body > main > section > button {
                font-size: 18px;
                text-align: center;
            }

            #ossys {
                display: none;
            }

            #sysfile {
                display: none;
                margin-bottom: 15px;                          
            }

            #process-thread {
                display: none;

            }

            #memory {
                display: none;
            }

            #soinstall {
                display: none;
            }

            #textareasoinstall {
                border-radius: 15px;
                border: 2px solid;
            }

            #show-first {
                position: relative;
                top: 300px;
                font-size: 40px;
                text-align: center;
            }

            .show-gab {
                text-align: center;                
            }
            
            #modal {
                display: none;
                position: fixed; /* Stay in place */
                z-index: 1; /* Sit on top */
                left: 0;
                top: 0;
                width: 100%; /* Full width */
                height: 100%; /* Full height */
                overflow: auto; /* Enable scroll if needed */
                background-color: rgb(0,0,0); /* Fallback color */
                background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            }

            #modal-content {
                background-color: #fefefe;
                margin: 15% auto; /* 15% from the top and centered */
                padding: 20px;
                border: 1px solid #888;
                width: 40%; /* Could be more or less, depending on screen size */
            }

            #modal > #modal-content > #close {
                float: right;
                font-size: 30px;
                font-weight: 600;
                cursor: pointer;
            }

        </style>
    </head>
    <body>
        <header>
            <ul>
                <li onclick="showById('ossys')">
                    Sistemas Operacionais
                </li>
                <li onclick="showById('sysfile')">
                    Sistemas de Arquivos
                </li>
                <li onclick="showById('process-thread')">
                    Processos e Threads
                </li>
                <li onclick="showById('memory')">
                    Memória
                </li>
                <li onclick="showById('soinstall')">
                    Instalação de um Sistema Operacional
                </li>                
            </ul>
        </header>
        <main>
            <section id="show-first">
                <h1>
                    Lista de Exercícios de Laboratório de Hardware
                </h1>
            </section>

            <section id="modal">
                <div id="modal-content">
                    <span id="close" onclick="closeTime()">&times;</span>
                    <div id="modal-html-content">
                    </div>
                </div>
            </section>

            <section id="ossys">
                <section class="show-gab">
                    <button onclick="showGabInf()">Ver Gabarito</button>
                </section>

                <h2>
                    Sistemas Operacionais
                </h2>

                <h3>1) Qual é a finalidade de um sistema operacional</h3>
    
                <input type="radio" name="finality-exec" > a) Organizar a disposição dos dados em um dado elemento de memória </br>
                <input type="radio" name="finality-exec" > b) Compilar linguagem de programação para linguagem de máquina </br>    
                <input type="radio" name="finality-exec" > c) Gerencia recursos do computador, oferece serviços para os programadores e distribui execução de outros programas. </br>
                <input type="radio" name="finality-exec" > d) Operacionalizar estruturas necessárias para que o usuário tenha acesso a internet
    
                
    
                <h3>2) Sobre sistemas operacionais assinale as alternativas Verdadeiras</h3>
    
                <input type="checkbox"> I)   torna o computador mais conveniente para o uso <br>
                <input type="checkbox"> II)  torna o computador mais eficiente porque o processamento ocorrerá de forma mais rápida <br>
                <input type="checkbox"> III) torna o computador mais eficiente porque sua ação diminui o uso da memória em tempo de execução <br>
                <input type="checkbox"> IV)  possibilita que os recursos do sistema sejam usados de uma maneira mais eficiente <br>
                <input type="checkbox"> V)   O conceito de um sistema operacional como uma abstrações para programas aplicativos pode ser considerada uma visão visão top-down
                <br>
                <br>
                <input type="radio" name="true-sistem-operation" > a) Apenas I, II e III    <br>
                <input type="radio" name="true-sistem-operation" > b) Apenas I, IV e V      <br>
                <input type="radio" name="true-sistem-operation" > c) Pelo menos IV e V     <br>
                <input type="radio" name="true-sistem-operation" > d) Apenas I, III,       
                
    
                <h3>3) Sobre utilidade do sistema operacional, marque a verdadeira</h3>
    
                <input type="radio" name="utility-so-using" > a) Apesar do desenvolvimento de software ser algo complexo, o s.o não contribui em nada para facilidade dessa atividade<br>
                <input type="radio" name="utility-so-using" > b) Não é papel do S.O esconder detalhes de hardware para o Programdor, logo essas questões devem ser pensadas por ele no momento de desenvolvimento do <i>software</i><br>
                <input type="radio" name="utility-so-using" > c) O SO oferece facilidades e serviços, como editores e depuradores, para auxiliar o programador na criação de programas.<br>
                <input type="radio" name="utility-so-using" > d) O sistema operacional não atua em questões vinculadas a entrada e saída de dados<br>
                
                <h3> 4) No que tange a Execução de Programas do S.O</h3>
                <input type="radio" name="finality-so" > a) O sistema operacional não tem responsabilidade nenhuma nisso<br>
                <input type="radio" name="finality-so" > b) Antes do programa ser executado, o S.O o carrega em um memória de rápido acesso conhecida como ROM, hoje em dia disponibilizada fisicamente em discos rígidos<br>
                <input type="radio" name="finality-so" > c) É impossível fazer algum tipo de execução de programas sem a disponibilidade de um sistema operacional<br>
                <input type="radio" name="finality-so" > d) Diversas tarefas precisam ser realizadas para executar um programa. As instruções/dados precisam ser carregados para a memória, dispositivos de E/S precisam ser inicializados, etc. O SO trata de tudo isso para o usuário.<br>
    
    
                <h3> 5) No que tange a Entrada e Saída</h3>
                <input type="radio" name="finality-so-inputoutput" > a) O sistema operacional gerencia apenas os dispositivos de entrada<br>
                <input type="radio" name="finality-so-inputoutput" > b) Teclado é o exemplo de um dispositivo de saída<br>
                <input type="radio" name="finality-so-inputoutput" > c) Nenhuma alternativa aqui presente é a correta<br>
                <input type="radio" name="finality-so-inputoutput" > d) Monitor é o exemplo de um dispositivo de entrada<br>
    
                <h3> 6) Sobre drivers assina-le a única errada</h3>
                <input type="radio" name="drivers-only-wrong" > a) Sistemas operacionais contêm muitos drivers para controlar dispositivos de E/S. <br>
                <input type="radio" name="drivers-only-wrong" > b) Como cada tipo de controlador (controlador de memória, de E/S etc.) é diferente, diversos softwares são necessários para controlar cada um. <br>
                <input type="radio" name="drivers-only-wrong" > c) Drivers são programas usados para fazer a edição de códigos cuja finalidade é executar algum tipo de operação no kernel do sistema operacional<br>
                <input type="radio" name="drivers-only-wrong" > d) O software que conversa com um controlador, dando a ele comandos e aceitando respostas, é chamado de driver de dispositivo. <br>
    
                <h3> 7) No que tange a relação de um sistema operacional e acessos ao sistema, marque a única errada</h3>
                <input type="radio" name="access-only-wrong" > a) No caso de um sistema compartilhado ou público, o SO controla o acesso ao sistema e a seus recursos.<br>
                <input type="radio" name="access-only-wrong" > b) No caso de um sistema compartilhado ou público, o SO oferece proteção de recursos e dados de usuários não autorizados, e resolve conflitos para disputa de recurso<br>
                <input type="radio" name="access-only-wrong" > c) A adminsitração de tipos de acessos a um dado arquivo não é de responsabilidade do sistema operacional<br>
                <input type="radio" name="access-only-wrong" > d) O SO precisa tomar uma medida que encerre a condição de erro com o mínimo de impacto sobre as aplicações em execução, no caso deles ocorrem tem tempo de execução<br>
    
                <h3> 8) No que tange ao Gerenciamento de Recursos</h3>
    
                <input type="checkbox"> I)   O conceito de um sistema operacional como uma abstrações para programas aplicativos pode ser considerada uma visão visão top-down
                <br>
                <input type="checkbox"> II)  Uma visão alternativa, bottom-up (abstração de baixo para cima), sustenta que o sistema operacional está ali para gerenciar todas as partes de um sistema complexo. <br>
                <input type="checkbox"> III) Na visão bottom-up, a função do sistema operacional é fornecer uma alocação ordenada e controlada dos processadores, memórias e dispositivos de E/S entre os vários programas competindo por eles. <br>
                <input type="checkbox"> IV)  O SO nunca abre mão do controle e precisa depender do processador para permitir que ele readquira o controle <br>
                <input type="checkbox"> V)   O SO não funciona da mesma maneira que o software comum do computador; ou seja, ele não é um programa executado pelo processador.
                <br>
                <br>
         
    
                <input type="radio" name="manager-resource" >a)I, IV, V<br>
                <input type="radio" name="manager-resource" >b)IV, V<br>
                <input type="radio" name="manager-resource" >c)III, IV, e V<br>
                <input type="radio" name="manager-resource" >d)I, II<br>
                <input type="radio" name="manager-resource" >e)I, II, III<br>
    
    
                <h3> 9) Disserte sobre o conceito de multiplexação no tempo, dando exemplo da relação S.O e CPU</h3>
                <textarea cols="100" rows="10" ></textarea>
    
    
                <h3> 10) Disserte sobre o conceito de multiplexação no espaço, dando exemplo da relação S.O e Memória</h3>
                <textarea cols="100" rows="10" ></textarea>
    
    
                <h3> 11) Descreva como ocorre o processo de inicialização de um computador</h3>
                <textarea cols="100" rows="10" ></textarea>
    
                <h3> 12) Disserte sobre os computadores a válvula, os computadores de primeira geração</h3>
                <textarea cols="100" rows="10" ></textarea>
    
                <h3> 13) Disserte sobre os computadores de segunda geração</h3>
                <textarea cols="100" rows="10" ></textarea>
    
                <h3> 14) Disserte sobre os computadores de terceira geração</h3>
                <textarea cols="100" rows="10" ></textarea>
    
                <h3> 15) Disserte sobre os computadores de quarta geração</h3>
                <textarea cols="100" rows="10" ></textarea>
    
                <h3> 16) Disserte sobre os computadores de quinta geração</h3>
                <textarea cols="100" rows="10" ></textarea>

            </section>

            <section id="sysfile">
                <section class="show-gab">
                    <button onclick="showGabInf()">Ver Gabarito</button>
                </section>

                <h2>Sistema de Arquivos</h2>
                <h3>1) Sobre Sistemas de Arquive marque as alternativas corretas</h3>

                <input type="checkbox"> I)    Conjunto de padrões usados para organizas os dados. <br>
                <input type="checkbox"> II)   Diretórios não são dados. <br>
                <input type="checkbox"> III)  Sistema de arquivos permitem gerenciar o espaço livre e o espaço ocupado <br>
                <input type="checkbox"> IV)   Não mantem a integridade dos dados
                <br>
                <br>
                <input type="radio" name="a" > a) I, II<br>
                <input type="radio" name="a" > b) II, IV<br>
                <input type="radio" name="a" > c) I, IV<br>
                <input type="radio" name="a" > d) nenhuma das alternativas
    
    
                <h3>2) Sobre a famíllia FAT, assina-le</h3>
    
                <input type="checkbox"> I) File Allocation Table (Tabela de alocação de arquivos) <br>
                <input type="checkbox"> II) Padrões de sistema DOS e Windows antigo <br>
                <input type="checkbox"> III) FAT 12 - Suporta arquivo de no máximo 32 MB Tamanho máximo de volume 32 MB<br>
                <input type="checkbox"> IV) FAT 16 - Suporta arquivo de no máximo 32 MB Tamanho máximo de volume 32 MB<br>
                <input type="checkbox"> V) FAT 32 - Suporta arquivo de no máximo 2/4 GB (com LFS - Large File Support) Tamanho máximo de volume 1 TB
                <br>            
                <br>
                <input type="radio" name="b" > a) I, II, III<br>
                <input type="radio" name="b" > b) I, V<br>
                <input type="radio" name="b" > c) I, IV<br>
                <input type="radio" name="b" > d) I, II, V 
    
    
    
                <h3>3) Sobre a família NTFS, assina-le</h3>
    
                <input type="checkbox"> I) Criado em 1995 <br>
                <input type="checkbox"> II) Não suporta criptografia<br>
                <input type="checkbox"> III) Trabalha com Journaling <br>
                <input type="checkbox"> IV) Compatível apenas com Windows e Linux kernel > 2.2<br>
                <input type="checkbox"> V) Compatível com todos os sistemas de kernel Linux
                <br>            
                <br>
                <input type="radio" name="c" > a) I, II<br>
                <input type="radio" name="c" > b) III, IV<br>
                <input type="radio" name="c" > c) I, IV<br>
                <input type="radio" name="c" > d) I, II, IV, V
    
    
                <h3>4) Sobre a família exFAT, assina-le</h3>
    
                <input type="checkbox"> I) Sistema proprietário, criado em 2006 pela Microsoft. <br>
                <input type="checkbox"> II) Max arq e volume 12PB <br>
                <input type="checkbox"> III) Para além dos sistemas Microsfot, possui suporte apenas para o(s) S.Os Android<br>
                <br>            
                <br>
                <input type="radio" name="d" > a) I, II<br>
                <input type="radio" name="d" > b) I<br>
                <input type="radio" name="d" > c) I, IV<br>
                <input type="radio" name="d" > d) I, II, III<br>
                <input type="radio" name="d" > e) III<br>
    
    
                <h3>5) Sobre a família ext, marque a correta</h3>
    
                <input type="radio" name="e" > a) Sitema de arquivos para Windows <br>
                <input type="radio" name="e" > b) Advento do Journaling começa no ext2<br>
                <input type="radio" name="e" > c) Tem suporte a Windows, nem OS X <br>
                <input type="radio" name="e" > d) Arquivos de até 16 TB/ 1 EB max storage <br>

    
                <h3>6) O que é e onde é usado os Sistemas de Arquivos HFS, HFS+ e APFS</h3>
                <textarea cols="100" rows="10" ></textarea>
    
                <h3>7) O que é e onde é usado os Sistemas de Arquivos ISO 9660</h3>
                <textarea cols="100" rows="10" ></textarea>
    
    
                <h3>8) Como consultor técnico de uma grande multinacional você precisa decidir em quais cenários os sistemas de arquivo NFTS, ext4, FAT32 e exFat devem ser usados. Apresente sua conclusão argumentando os motivos de cada escolha</h3>
                <textarea cols="100" rows="10" ></textarea>
            </section>

            <section id="process-thread">
                <section class="show-gab">
                    <button onclick="showGabInf()">Ver Gabarito</button>
                </section>

                <h2>Processos e Threads</h2>
                <h3>1) Assine as alternativas verdadeiras sobre processos</h3>

                <input type="checkbox">  I   É um programa em execução <br>
                <input type="checkbox">  II  A CPU consegue executar vários processos ao mesmo tempo <br>
                <input type="checkbox">  III Um determinado processo pode ser iniciado apenas uma vez<br>
                <input type="checkbox">  IV  Em um sistema de multiprogramação a CPU muda de um processo para outro muito rapidamente (em ms).
                <br>
                <br>
                <input type="radio" name="radio1" > a) IV <br>
                <input type="radio" name="radio1" > b) I, II, IV<br>
                <input type="radio" name="radio1" > c) I, II<br>
                <input type="radio" name="radio1" > d) I e IV       
    
                <h3>2) Sobre multiprogramação, marque a verdadeira</h3>
    
                <input type="radio" name="radio2" > a) É o ato do processador executar vários processos ao mesmo tempo <br>
                <input type="radio" name="radio2" > b) Multiprogramação não é um termo utilizado dentro do contexto da computação<br>
                <input type="radio" name="radio2" > c) Em um sistema de multiprogramação a CPU muda de um processo para outro muito rapidamente (em ms).<br>
                <input type="radio" name="radio2" > d) Em um sistema de multiprogramação a CPU muda de um processo para outro na ordem de s.
    
    
                <h3>3) Sobre Endereçamento de memória, marque a falsa</h3>
    
                <input type="radio" name="radio3" > a) Cada processo é associado a um dado espaço de endereçamento. Isso consiste em uma lista de posições de memória que vão de 0 a algum máximo onde o processo pode ler e escrever.<br>
                <input type="radio" name="radio3" > b) O espaço de endereçamento consiste no no tempo alocado pela cpu para executar determinado procedimento<br>
                <input type="radio" name="radio3" > c) A pilha contém uma estrutura para cada rotina (conjuntos e instruções), que foi chamada mas ainda não encerrada.<br>
                <input type="radio" name="radio3" > d) Um processo é na essência um contêiner que armazena todas as informações necessárias para executar um programa
    
    
                <h3>4) Dentro do contexto de processos e de programação marque a alternativa falsa</h3>
    
                <input type="radio" name="radio5" > a) O usuário pode ter inicializado um programa de edição de vídeo e mandou converter um vídeo de uma hora para um formato MP4 (algo que pode levar horas) e então foi navegar na web enquanto convertia.<br>
                <input type="radio" name="radio5" > b) Periodicamente, o sistema operacional decide parar de executar um processo e começa a executar outro, talvez porque o primeiro utilizou mais do que sua parcela de tempo da CPU no último segundo ou dois<br>
                <input type="radio" name="radio5" > c) Um processo que é suspenso temporiamente pela cpu não é retomando no exato estado da suspensão, mas sim de seu início.<br>
                <input type="radio" name="radio5" > d) Um processo é na essência um contêiner que armazena todas as informações necessárias para executar um programa
    
                <h3>5) Quais são as principais chamadas do sistema de gerenciamento de processos?</h3>
                <textarea cols="100" rows="10" ></textarea>
    
                <h3>6) Quais são os três estados de um processo? Apresente uma descrição de cada estado </h3>
                <textarea cols="100" rows="10" ></textarea>
    
                <h3>7) Ainda no contexto da questão 7 apresente as 4 transições de estado possíveis, forneça uma descrição de cada estado  </h3>
                <textarea cols="100" rows="10" ></textarea>
    
                <h3>8) Quais são as possibilidades de término de processos?  </h3>
                <textarea cols="100" rows="10" ></textarea>
    
                <h3>9) O que são Threads?  </h3>
                <textarea cols="100" rows="10" ></textarea>
            </section>

            <section id="memory">
                <section class="show-gab">
                    <button onclick="showGabInf()">Ver Gabarito</button>
                </section>

                <h3>1) Sobre o conceito de hierarquia de memória, assinal-e a falsa</h3>

                <input type="radio" name="memory1" > a) A memória do computador é organizada em uma hierarquia.<br>
                <input type="radio" name="memory1" > b) No nível mais alto é aquele que está mais próximo do disco rígido.<br>
                <input type="radio" name="memory1" > c) Em seguida, vem a memória principal, que normalmente é uma memória dinâmica de acesso aleatório e dinâmico (DRAM).<br>
                <input type="radio" name="memory1" > d) No nível mais alto (mais perto do processador), estão os registradores do processador.
    
                <h3>2) Ainda dentro do contexto de hierarquia de memória, assina-le a alternativa verdadeira</h3>

                <input type="radio" name="memory2" > a) Memórias dentro do processor, memória de cache ao processador e a DRAM são consideraras memórias internas ao computador<br>
                <input type="radio" name="memory2" > b) Disco rígido é uma memória interna ao computador<br>
                <input type="radio" name="memory2" > c) A medida que descemos a hierarquia de memória o custo por bit se torna maior<br>
                <input type="radio" name="memory2" > d) A memória interna possui um cust por bit maior do que as memórias externas
                
                <h3>3) Se a memória cache for construída corretamente, então:</h3>
    
                <input type="radio" name="memory3" > a) O processador acessará a memória DRAM <br>
                <input type="radio" name="memory3" > b) O processador solicitará palavras da memória que já estão na cache, e não precisará buscar na DRAM <br>
                <input type="radio" name="memory3" > c) O processador acessador acessará a memória externa, necessariamente. <br>
                <input type="radio" name="memory3" > d) O processador ficará inoperante
    
    
                <h3>4) Quanto as questões que resumem a restrição de memória?</h3>
           
                <input type="radio" name="memory4" > a) A velocidade de acesso é apenas a única informação relevante<br>
                <input type="radio" name="memory4" > b) Qual é o custo da memória? É apenas a únifca informação relevante<br>
                <input type="radio" name="memory4" > c) Qual é o custo da memória? Essa é uma informação relevante.<br>
                <input type="radio" name="memory4" > d) A capacidade de armanamento é totalmente irrelevante.<br>
                
                <h3>5) A dinâmica dos sistemas de memória se dão da seguinte maneira:</h3>
    
                <input type="radio" name="memory5" > a) Tempo de acesso mais rápido, maior custo por bit. Maior capacidade, menor custo por bit. Maior capacidade, tempo de acesso mais rápido.<br>
                <input type="radio" name="memory5" > b) Tempo de acesso mais devagar, maior custo por bit. Maior capacidade, menor custo por bit. Maior capacidade, tempo de acesso mais devagar.<br>
                <input type="radio" name="memory5" > c) Tempo de acesso mais rápido, menor custo por bit. Maior capacidade, maior custo por bit. Maior capacidade, tempo de acesso mais lento.<br>
                <input type="radio" name="memory5" > d) Tempo de acesso mais rápido, maior custo por bit. Maior capacidade, menor custo por bit. Maior capacidade, tempo de acesso mais lento.<br>
    
                <h3>6) Sobre método de acesso de memória</h3>
    
                <input type="radio" name="memory6" > a) Acesso sequencial: a memória é organizada em unidades de dados chamadas registros. O acesso é feito em uma sequência linear específica. O tempo para acessar um registro qualquer é altamente variável. As unidades de fita não são de acesso sequencial. <br>
                <input type="radio" name="memory6" > b) Acesso direto: os blocos ou registros individuais têm um endereço exclusivo, baseado no local físico. O tempo de acesso é fixo.<br>
                <input type="radio" name="memory6" > c) Acesso aleatório: cada local endereçável na memória tem um mecanismo de endereçamento exclusivo, fisicamente interligado. O tempo para acessar determinado local é independente da sequência de acessos anteriores, e é constante. Assim, qualquer local pode ser selecionado aleatoriamente, e endereçado e acessado diretamente. A memória principal e alguns sistemas de cache são de acesso aleatório.<br>
                <input type="radio" name="memory6" > d) Associativo: tipo de memória de acesso aleatório que permite fazer uma comparação de um certo número de bit desejados dentro de uma palavra para uma combinação especificada, e faz isso para todas as palavras simultaneamente. Assim, uma palavra é recuperada com base em uma parte de seu conteúdo, em vez do seu endereço. o tempo de recuperação é constante, independentemente do local ou padrões de acesso anteriores. As memórias cache podem empregar o acesso não associativo.<br>
    
    
                <h3>7) Sobre o desempenho </h3>
                
                <input type="radio" name="memory7" > a) Tempo de acesso (latência): para a memória de acesso constante, esse é o tempo gasto para realizar uma operação de leitura ou escrita, ou seja, o tempo desde o instante em que um endereço é apresentado à memória até o instante em que os dados foram armazenados ou se tornaram disponíveis para uso.<br>
                <input type="radio" name="memory7" > b) Para a memória de acesso não aleatório, o tempo de acesso é o tempo gasto para posicionar o mecanismo de leitura no local desejado.<br>
                <input type="radio" name="memory7" > c) Para memória de acesso não aleatório, a taxa de transferência é de 1/(tempo de ciclo)<br>
                <input type="radio" name="memory7" > d) Para a memória de acesso não aleatório, a taxa de transferência é dada por <e>Tn = Ta + (n/R)</e><br>
    
    
                <h3>8) Sobre a equação <e>Tn = Ta + (n/R)</e> </h3>
                
                <input type="radio" name="memory7" > a) Tn tempo médio para ler ou escrever N bits, Ta tempo de acesso médio, n número de bits, R taxa de transferência em bits por segundo<br>
                <input type="radio" name="memory7" > b) Tn tempo médio apenas para ler N bits, Ta tempo de acesso médio, n número de bits, R taxa de transferência em bits por segundo<br>
                <input type="radio" name="memory7" > c) Tn tempo médio apenas para ler N bits, Ta tempo de acesso médio, n número de bits, R taxa de transferência de acesso do bit<br>
                <input type="radio" name="memory7" > d) Tn tempo médio apenas para ler N bits, Ta tempo absoluto de acesso, n número de bits, R taxa de transferência de acesso do bit<br>
    
    
                <h3>9) O conceito de memória volátil é: </h3>
                
                <input type="radio" name="memory8" > a) A informação não se deteriora naturalmente<br>
                <input type="radio" name="memory8" > b) Memórias com superfície magnética (disco rígido) são voláteis <br>
                <input type="radio" name="memory8" > c) Memória semicondutora não pode ser volátil ou não (registradores, caches)<br>
                <input type="radio" name="memory8" > d) A informação se deteriora naturalmente ou se perde quando a energia elétrica é desligada.<br>

                
            </section>

            <section id="soinstall">
                <section class="show-gab">
                    <button onclick="showGabInf()">Ver Gabarito</button>
                </section>


                <h3>1) Defina as etapas de instalação de um S.O (Windows, Linux)</h3>

                <ol>
                    <li> <input type="checkbox"> Adicionar dispositivo de mídia de instalação (Pendrive ao USB, DVD ao dispositivo de mídia)</li>
                    <li> <input type="checkbox"> Cópia dos arquivos de instalação para a mídia onde s.o está sendo instalado</li>
                    <li> <input type="checkbox"> Formatar o Disco Rígido</li>
                    <li> <input type="checkbox"> Configurações pré-instalação</li>
                    <li> <input type="checkbox"> Ligar o computador</li>
                    <li> <input type="checkbox"> Pressionar F10 e reiniciar o computador</li>
                    <li> <input type="checkbox"> Acessar a BIOS, em algums computadores é com F2 já em outros é com DEL</li>
                    <li> <input type="checkbox"> Configurações pós-instalação</li>
                    <li> <input type="checkbox"> Mudar a configuração de boot para a mídia onde os arquivos de instalação s.o está instalado</li>
                    <li> <input type="checkbox"> Iniciar o programa de instalação</li>
                    <li> <input type="checkbox"> Remover partiçoes e/ou criar partições novas</li>
                    <li> <input type="checkbox"> Execução da instalação propriamente dita</li>            
                </ol>
        
                <textarea id="textareasoinstall" cols="100" rows="2" >
                </textarea>

            </section>
        </main>

        <footer>
            <span>
                Desenvolvido por Jonathan Morris Samara
            </span>
            <span>
                https://github.com/joneng2016
            </span>
            <span>
                https://www.linkedin.com/in/jonathan-morris-samara-3a45356a/
            </span>
        </footer>
        <script>
            let allIds = [
                'ossys', 
                'sysfile', 
                'process-thread',
                'memory',
                'show-first',
                'soinstall'
            ]

            mainProcess()

            function mainProcess() {
                const inputVars = window.location.href.split('?')
                let idString = ''

                if (inputVars[1]) {
                    const variableSelected = inputVars[1].split('=')

                    if (variableSelected[0] == 'name') {
                        idString = variableSelected[1]
                    }

                    showById(idString)
                }
            }

            function showById(idString) {
                _defineAllLikeNone()
                document.getElementById(idString).style.display = 'block'
            }

            function showGabInf() {
                const stringIdOs = allIds.find((e) => {
                    return document.getElementById(e).style.display === 'block'
                })

                document.getElementById("modal").style.display = 'block'

                const docStructure = [
                    {
                        nameId:'ossys',
                        title:'Sistemas Operacionais',
                        questions:[
                            _questionResponseObject(1, 'a'),
                            _questionResponseObject(2, 'b'),
                            _questionResponseObject(3, 'c'),
                            _questionResponseObject(4, 'd'),
                            _questionResponseObject(5, 'c'),
                            _questionResponseObject(6, 'd'),
                            _questionResponseObject(7, 'c'),
                            _questionResponseObject(8, 'e'),
                            _questionResponseObject(9, '<p>O gerenciamento de recursos inclui a multiplexação (compartilhamento) de recursos de duas maneiras diferentes: no tempo e no espaço. Quando um recurso é multiplexado no tempo, diferentes programas ou usuários se revezam usando-o. Primeiro, um deles usa o recurso, então outro e assim por diante.  Por exemplo, com apenas uma CPU e múltiplos programas querendo ser executados nela, o sistema operacional primeiro aloca a CPU para um programa, então, após ele ter sido executado por tempo suficiente, outro programa passa a fazer uso da CPU, então outro, e finalmente o primeiro de novo. Determinar como o recurso é multiplexado no tempo — quem vai em seguida e por quanto tempo — é a tarefa do sistema operacional.</p>'),
                            _questionResponseObject(10, '<p>O outro tipo é a multiplexação de espaço. Em vez de os clientes se revezarem, cada um tem direito a uma parte do recurso. Por exemplo, a memória principal é normalmente dividida entre vários programas sendo executados, de modo que cada um pode ser residente ao mesmo tempo</p>'),
                            _questionResponseObject(11, '<ol><li>nas placas-mãe há um programa chamado de sistema BIOS (Basic Input Output System — sistema básico de entrada e saída).</li><li>O BIOS conta com rotinas de E/S de baixo nível, incluindo procedimentos para ler o teclado, escrever na tela e realizar a E/S no disco, entre outras coisas</li><li>Hoje, ele fica em um flash RAM, que é não volátil, mas que pode ser atualizado pelo sistema operacional quando erros são encontrados no BIOS.</li></ol>'),
                            _questionResponseObject(12, '<p> Entre os computadores dessa época, alguns eram binários, outros usavam válvulas e ainda outros eram programáveis, mas todos eram muito primitivos e levavam segundos para realizar mesmo o cálculo mais simples. </p> <p> Um único grupo de pessoas (normalmente engenheiros) projetava, construía, programava, operava e mantinha cada máquina. Toda a programação era feita em código de máquina absoluto, ou, pior ainda, ligando circuitos elétricos através da conexão de milhares de cabos a painéis de ligações para controlar as funções básicas da máquina.  </p> <p> Linguagens de programação eram desconhecidas Ninguém tinha ouvido falar ainda de sistemas operacionais.  </p> <p> O modo usual de operação consistia na reserva pelo programador de um bloco de tempo na ficha de registro na parede, então ele descer até a sala de máquinas, inserir seu painel de programação no computador e passar as horas seguintes torcendo para que nenhuma das cerca de 20.000 válvulas queimasse durante a operação.  </p> <p>No início da década de 1950, a rotina havia melhorado de certa maneira com a introdução dos cartões perfurados. Era possível agora escrever programas em cartões e lê-los em vez de se usarem painéis de programação de resto, o procedimento era o mesmo.</p>'),
                            _questionResponseObject(13, '<p>A introdução do transistor em meados dos anos 1950 mudou o quadro radicalmente. Os computadores tornaram-se de tal maneira confiáveis que podiam ser fabricados e vendidos para clientes dispostos a pagar por eles com a expectativa de que continuariam a funcionar por tempo suficiente para realizar algum trabalho útil. </p> <p> Pela primeira vez, havia uma clara separação entre projetistas, construtores, operadores, programadores e pessoal de manutenção. Essas máquinas — então chamadas de computadores de grande porte (mainframes) —, ficavam isoladas em salas grandes e climatizadas, especialmente designadas para esse fim, com equipes de operadores profissionais para operá-las. </p> <p> Para executar uma tarefa [isto é, um programa ou conjunto de programas], um programador primeiro escrevia o programa no papel [em FORTRAN ou em linguagem de montagem (assembly)], então o perfurava nos cartões. Ele levava então o maço de cartões até a sala de entradas e o passava a um dos operadores e ia tomar um café até que a saída estivesse pronta </p> <p> Quando o computador terminava qualquer tarefa que ele estivesse executando no momento, um operador ia até a impressora, pegava a sua saída e a levava até a sala de saídas a fim de que o programador pudesse buscá-la mais tarde. </p> <p> Dado o alto custo do equipamento, não causa surpresa que as pessoas logo procuraram maneiras de reduzir o tempo desperdiçado. A solução geralmente adotada era o sistema em lote (batch). Os sistemas puramente em lote são raros hoje.  </p> <p> A ideia por trás disso era reunir um lote de tarefas na sala de entradas e então passá-lo para uma fita magnética usando um computador pequeno e (relativamente) barato, como um IBM 1401, que era muito bom na leitura de cartões, cópia de fitas e impressão de saídas</p>'),
                            _questionResponseObject(14, '<p> O 360 era uma série de máquinas com softwares compatíveis, desde modelos do porte do 1401 a modelos muito maiores, mais potentes que o poderoso </p> <p> As máquinas diferiam apenas em preço e desempenho. Tendo em vista que todos tinham a mesma arquitetura e conjunto de instruções, programas escritos para uma máquina podiam operar em todas as outras — pelo menos na teoria. </p> <p> Nos anos seguintes, a IBM apresentou sucessores compatíveis com a linha 360, usando tecnologias mais modernas, conhecidas como as séries 370, 4300, 3080 e 3090. O IBM 360 foi a primeira linha importante de computadores a usar CIs (circuitos integrados) de pequena escala, proporcionando desse modo uma vantagem significativa na relação preço/desempenho sobre as máquinas de segunda geração, que foram construídas sobre transistores individuais. </p> <p> Nos anos seguintes, a IBM apresentou sucessores compatíveis com a linha 360, usando tecnologias mais modernas, conhecidas como as séries 370, 4300, 3080 e 3090. O IBM 360 foi a primeira linha importante de computadores a usar CIs (circuitos integrados) de pequena escala, proporcionando desse modo uma vantagem significativa na relação preço/desempenho sobre as máquinas de segunda geração, que foram construídas sobre transistores individuais. </p> <p> O forte da ideia da “família única” foi ao mesmo tempo seu maior ponto fraco. A intenção original era de que todo software, incluindo o sistema operacional, OS/360, funcionasse em todos os modelos. Não havia como a IBM (ou qualquer outra empresa) criar um software que atendesse a todas essas exigências de funcionar em máquinas diferentes. O resultado foi um sistema operacional enorme e extraordinariamente complexo </p> <p> Apesar dos problemas, o OS/360 e os sistemas operacionais de terceira geração similares produzidos na realidade proporcionaram um grau de satisfação bom Eles popularizaram várias técnicas-chave ausentes nos sistemas operacionais de segunda geração. Talvez a mais importante dessas técnicas tenha sido a multiprogramação. </p> <p> No 7094, quando a tarefa atual fazia uma pausa para esperar por uma fita ou outra operação de E/S terminar, a CPU simplesmente ficava ociosa até o término da E/S. A solução encontrada foi dividir a memória em várias partes, com uma tarefa diferente em cada partição Enquanto uma tarefa ficava esperando pelo término da E/S, outra podia usar a CPU. </p> <p> Se um número suficiente de tarefas pudesse ser armazenado na memória principal ao mesmo tempo, a CPU podia se manter ocupada quase 100% do tempo. Ter múltiplas tarefas na memória ao mesmo tempo de modo seguro exige um hardware especial para proteger cada uma contra interferências e transgressões por parte das outras </p> <p> Os sistemas operacionais de terceira geração ainda eram basicamente sistemas em lote. Muitos programadores sentiam saudades dos tempos de computadores de primeira geração quando eles tinham a máquina só para si por algumas horas e assim podiam corrigir eventuais erros em seus programas rapidamente. Com sistemas de terceira geração, o tempo entre submeter uma tarefa e receber de volta a saída era muitas vezes de várias horas. Programadores não gostavam muito disso. </p> <p> Esse desejo por um tempo de resposta rápido abriu o caminho para o timesharing (compartilhamento de tempo), uma variante da multiprogramação, na qual cada usuário tem um terminal on-line. </p>'),
                            _questionResponseObject(15, '<p> Com o desenvolvimento dos circuitos integrados em larga escala (Large Scale Integration — LSI) — que são chips contendo milhares de transistores em um centímetro quadrado, surgiu a era do computador moderno. </p> <p> No início da década de 1980, a IBM projetou o IBM PC e saiu à procura de um software para ser executado nele. O pessoal na IBM contatou Bill Gates para licenciar o seu interpretador BASIC. Eles também perguntaram se ele tinha conhecimento de um sistema operacional para ser executado no PC. </p> <p> Gates se deu conta de que uma fabricante de computadores local, Seattle Computer Products, tinha um sistema operacional adequado, DOS (Disk Operating System — sistema operacional de disco). Ele os procurou e pediu para comprá-lo (supostamente por US$ 75.000), oferta que eles de pronto aceitaram. </p> <p> Gates ofereceu então à IBM um pacote DOS/BASIC, que a empresa aceitou. Gates se deu conta de que uma fabricante de computadores local, Seattle Computer Products, tinha um sistema operacional adequado, DOS (Disk Operating System — sistema operacional de disco). Ele os procurou e pediu para comprá-lo (supostamente por US$ 75.000), oferta que eles de pronto aceitaram. </p> <p> Gates ofereceu então à IBM um pacote DOS/BASIC, que a empresa aceitou. A IBM queria fazer modificações, então Gates contratou para a Microsoft a pessoa que havia escrito o DOS, Tim Paterson para fazê-las. O sistema revisado foi renomeado MS-DOS (MicroSoft Disk Operating System) e logo passou a dominar o mercado do IBM PC. MS-DOS e outros SOs para os primeiros microcomputadores eram todos baseados na digitação de comandos no teclado pelos usuários.  Isto finalmente mudou por conta da pesquisa realizada por Doug Engelbert no Instituto de Pesquisa de Stanford na década de 1960. Engelbart inventou a Graphical User Interface (GUI — Interface Gráfica do Usuário), completa com janelas, ícones, menus e mouse. Essas ideias foram adotadas por pesquisadores na Xerox PARC e incorporadas nas máquinas que eles produziram </p> <p> Um dia, Steve Jobs, que coinventou o computador Apple em sua garagem, visitou a PARC, viu uma GUI e no mesmo instante percebeu o seu valor potencial Jobs partiu foi produzir um Apple com o GUI. O projeto levou ao Lisa, que era caro demais e fracassou. A 2ª tentativa, o Apple Macintosh, foi um sucesso, por ser amigável ao usuário, significando que era dirigido a usuários que não apenas não sabiam nada sobre computadores como não tinham intenção alguma de aprender sobre eles. </p> <p> Quando decidiu produzir um sucessor para o MS- -DOS, a Microsoft foi fortemente influenciada pelo sucesso do Macintosh. Ela produziu um sistema baseado em GUI chamado Windows, que originalmente era executado em cima do MS-DOS </p> <p> Por cerca de dez anos, de 1985 a 1995, o Windows era apenas um ambiente gráfico sobre o MS-DOS. Entretanto, começando em 1995, uma versão independente, Windows 95, foi lançada incorporando muitos aspectos de sistemas operacionais Em 1998, uma versão ligeiramente modificada deste sistema, chamada Windows 98, foi lançada. </p>'),
                            _questionResponseObject(16, '<p> O primeiro telefone móvel real apareceu em 1946 e pesava em torno de 40 quilos. Você podia levá-lo para toda parte, desde que você tivesse um carro para carregá-lo. O primeiro telefone verdadeiramente móvel foi criado na década de 1970 e, pesando cerca de um quilo, era positivamente um peso-pena. Ele ficou conhecido carinhosamente como “o tijolo”. <p> </p> A ideia de combinar a telefonia e a computação em um telefone exista desde a década de 1970 Somente em meados de 1990, quando a Nokia lançou o N9000, isso ocorreu: combinava dois dispositivos mormente separados: um telefone e um PDA (Personal Digital Assistant) Em 1997, a Ericsson cunhou o termo smartphone para o seu “Penelope” GS88. <p> </p> A maioria dos smartphones na primeira década após sua criação era executada em Symbian OS. Era o sistema operacional escolhido para as marcas populares como Samsung, Sony Ericsson, Motorola e especialmente Nokia A participação de mercado do Symbian desabou. Em 2011, a Nokia abandonou o Symbian e anunciou que se concentraria no Windows Phone como sua principal plataforma. </p>')
                        ]
                    },
                    {
                        nameId:'sysfile',
                        title:'Sistema de Arquivos',
                        questions:[
                            _questionResponseObject(1, 'd'),
                            _questionResponseObject(2, 'a'),
                            _questionResponseObject(3, 'b'),
                            _questionResponseObject(4, 'a'),
                            _questionResponseObject(5, 'd'),
                            _questionResponseObject(6, '<ul><li>Sitema de arquivos para Apple OS (OS X</li><li>Suporta arquivos de 2GB e volumes de 2TB</li><li>APFS - mais moderno</li><li>Tamanho máxi de arquivo e volume 8 EB</li><li>Apenas Apple</li></ul>'),
                            _questionResponseObject(7, '<ul><li>Padrão orignal CD</li><li>Nomes de arquivos: 8.3 caracteres</li><li>Tamanho de volume restrido pelo tamanho da mídia de até 4 GB</li><li>Suportado em Mac OS, Unix, Linux e Windows</li></ul>'),
                            _questionResponseObject(8, '<p>NFTS é indicado para sistemas Windows, por possuir Journaling e melhor integração com produtos Microsoft. Já o ext4 é indicado para dispositivos equivalentes, contudo para Linux - pelos mesmos motivos daquele. FAT32 e exFAT são ótimas alternativas para dispositivos de mídia removíveis uma vez que são sistemas de arquivos mais simples.</p>'),
                        ]
                    },
                    {
                        nameId:'process-thread',
                        title:'Processos e Threads',
                        questions:[
                            _questionResponseObject(1, 'd'),
                            _questionResponseObject(2, 'c'),
                            _questionResponseObject(3, 'b'),
                            _questionResponseObject(4, 'c'),
                            _questionResponseObject(5, '<p> As principais chamadas de sistema de gerenciamento de processos são as que lidam com a criação e o término de processos. Exemplo: Um processo chamado de interpretador de comandos ou shell lê os comandos de um terminal. O usuário acabou de digitar um comando requisitando que um programa seja compilado. O shell tem de criar agora um novo processo que vai executar o compilador. Quando esse processo tiver terminado a compilação, ele executa uma chamada de sistema para se autofinalizar.</p>'),
                            _questionResponseObject(6, '<ul><li>Em execução (realmente usando a CPU naquele instante).</li><li>Pronto (executável, temporariamente parado para deixar outro processo ser executado).</li><li>Bloqueado (incapaz de ser executado até que algum evento externo aconteça). O terceiro estado é fundamentalmente diferente dos dois primeiros, pois o processo não pode ser executado, mesmo que a CPU esteja ociosa e não tenha nada mais a fazer.</li></ul>'),
                            _questionResponseObject(7, '<ul><li>A transição 1 ocorre quando o sistema operacional descobre que um processo não pode continuar agora. Em alguns sistemas o processo pode executar uma chamada de sistema, como em pause, para entrar em um estado bloqueado.</li><li>As transições 2 e 3 são causadas pelo escalonador de processos, uma parte do sistema operacional, sem o processo nem saber a respeito delas. Escalonamento: decidir qual processo deve ser executado, quando e por quanto tempo</li><li>A transição 2 ocorre quando o escalonador decide que o processo em andamento foi executado por tempo suficiente, e é o momento de outro ter algum tempo de CPU.</li><li>A transição 3 ocorre quando todos os outros processos tiveram sua parcela justa e está na hora de o primeiro processo chegar à CPU para ser executado novamente.</li><li>A transição 4 se verifica quando o evento externo pelo qual um processo estava esperando (como a chegada de alguma entrada) acontece.</li><li>As informações são salvas quando um processo é trocado do estado em execução para pronto ou bloqueado, são de maneira que ele possa ser reiniciado mais tarde como se nunca tivesse sido parado.</li></ul>'),
                            _questionResponseObject(8, '<ul><li>A maioria dos processos termina por terem realizado o seu trabalho. Quando um compilador termina de traduzir o programa dado a ele, o compilador executa uma chamada para dizer ao sistema operacional que ele terminou.</li><li>Essa chamada é exit em UNIX e ExitProcess no Windows.<li>Saída normal (voluntária)</li><li>Erro fatal (involuntário)</li><li>Saída por erro (voluntária)</li><li>Morto por outro processo (involuntário)</li><li>Exemplos de erro de programa: executar uma instrução</li></ul>'),
                            _questionResponseObject(9, '<ul><li>São processos com espaço de endereçamento compartilhado (*processos leves*)</li><li>Os threads acrescentam a capacidade para entidades em paralelo compartilharem um espaço de endereçamento e todos os seus dados entre si.</li><li>Um segundo argumento para a existência dos threads é que como eles são mais leves do que os processos, eles são mais fáceis (mais rápidos) para criar e destruir do que os processos (criar um thread pode ser algo de 10 a 100 vezes mais rápido do que criar um processo).</li></ul>')
                        ]
                    },
                    {
                        nameId:"memory",
                        title:"Memória",
                        questions:[
                            _questionResponseObject(1, 'b'),
                            _questionResponseObject(2, 'a'),
                            _questionResponseObject(3, 'b'),
                            _questionResponseObject(4, 'c'),
                            _questionResponseObject(5, 'd'),
                            _questionResponseObject(6, 'd'),
                            _questionResponseObject(7, 'd'),
                            _questionResponseObject(8, 'c'),
                            _questionResponseObject(9, 'd')                                                        
                        ]
                    },
                    {
                        nameId:"soinstall",
                        title:"Instalação de Sistema Operacional",
                        questions:[
                            _questionResponseObject(1, "1,5,7,9,6,10,11,3,4,2,12,8")                                                        
                        ]
                    }
                ]

                const dataStructure = docStructure.find(e => e.nameId === stringIdOs)

                if (!dataStructure) {
                    document.getElementById("modal-html-content").innerHTML = `<h2>Sem Gabarito no momento</h2>`
                } else {
                    document.getElementById("modal-html-content").innerHTML = [
                        `<h2>${dataStructure.title}</h2>`, 
                        dataStructure.questions.map(e => `<span><strong>${e.question}</strong>: ${e.response}</span><br>`).join('')
                    ].join('')
                }

            }

            function closeTime() {
                document.getElementById("modal-html-content").innerHTML = ""
                document.getElementById("modal").style.display = 'none'
            }

            function _defineAllLikeNone() {
                allIds.forEach(e => document.getElementById(e).style.display = 'none')
            }

            function _questionResponseObject(question, response) {
                return {question, response}
            }
        </script>
    </body>
</html>